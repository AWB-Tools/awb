:
eval 'exec perl "$0" ${1+"$@"}'
       if 0;

#
# Copyright (C) 2002-2006 Intel Corporation
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# 
#

$| = 1;

#
#
# The purpose of this script is to automatically perform a merge of
# two source trees, called the LOCAL tree and the VENDOR tree.
#
# This is useful to keep two processor trees in sync, assuming that
# one processor is derived from the other. An example might clarify
# things:
#
# asim/pm/arana is the source tree corresponding to our Arana
# implementation
#
# asim/pm/tarantula is the source tree for a cpu that heavily borrows
#                   from Arana boxes, but that also has its own boxes.
#
# The typical problem you run into if you are a developer of
# 'tarantula' is that the Arana boys/girls work very fast... so they
# keep improving your model while you are working on yours. Imagine
# for example that tarantula needs a PBOX that is slightly different
# than the PBOX in Arana. Although we usually can reuse most of the
# Arana_PBOX components (such as the MC, INA,...) you probably have
# been forced to create a copy of pbox.h and pbox.cpp to suit the
# needs of tarantula.
#
# Now, when the Arana boys/girls update their PBOX code, you should
# probably be also getting their fixes into your local taranatula-PBOX
# code, shouldn't you?
#
# This script helps you automate that process by using the 'IMPORT'
# feature of CVS.
#
# Using this feature, we consider the 'tarantula' source tree to be
# the 'LOCAL' tree that is derived (and improves upon) a source tree
# provided by an 'OUTSIDE VENDOR' :-) As the vendor releases new
# versions of his VENDOR CODE (i.e., as the Arana crowd improve their
# code) we want to merge those improvements to our local source tree
#
# roger July/99
#


#
# We receive the following parameters:
#
# ARGV[0] = LOCAL source tree module (relative to $CVSROOT)
#
# ARGV[1] = VENDOR source tree module (relative to $CVSROOT)
#
#
# We use the following environment variables
#
#  - $CVSROOT
#  - $ASIMDIR
#
#

$RESOLVER = "awb-resolver";
chomp ($msg = `$RESOLVER .`);
if ($? != 0) {
  die "Can't find $RESOLVER - check your PATH environemt variable\n$msg\n";
}

sub usage
{
 print "\n";
 print "Usage: cvs-sync <local-module> <vendor-module>\n";
 print "\n";
 print "     <local-module> is relative to \$ASIMDIR\n";
 print "     <vendor-module> is relative to \$ASIMDIR\n";
 print "\n";
 exit -1;
}

sub getinput
{
 my($msg) = $_[0];
 my($val) = $_[1];

 print "$msg [$val] (<cr> to accept suggestion):";
 $in = <STDIN>;

 if ( $in ne "\n" ) {
  chop $in;
  return $in;
 }

 return $val;
}

sub rcs_date
{
 my($sec, $min, $hour, $mday, $mon, $year, $rest);

 ( $sec, $min, $hour, $mday, $mon, $year, $rest )  = localtime(time);

 return "$year/$mon/$mday $hour:$min:$sec";
}

sub conditional_exit
{
 my($yorno) = $_[0];

 if ( $yorno ne "y" && $yorno ne "yes" ) {
  print "Exiting...";
  exit 1;
 }
}

 #
 # Check for CVSROOT
 #
 $cvsroot = $ENV{'CVSROOT'};
 die "Undefined \$CVSROOT variable in environment\n" unless  ( $cvsroot );

 # Removed to allow remote operation under SSH -- roger, Sep/00
 #if ( ! -d $cvsroot ) {
 # die "CVSROOT=$cvsroot is not a directory: $!\n";
 #}

 #
 # Check for ASIMDIR
 #
 chomp ($asimdir = `$RESOLVER -config asimdir`);
 if ($? != 0) {
   die "ERROR:\n$asimdir\n";
 }
 # (r2r) ASIMDIR env is not used by AWB - using standard access method
 #$asimdir = $ENV{'ASIMDIR'};
 die "Undefined \$ASIMDIR variable in environment\n" unless  ( $asimdir );

 if ( ! -d $asimdir ) {
  die "ASIMDIR=$asimdir is not a directory: $!\n";
 }

 #
 # Check for TMPDIR
 #
 $tmpdir = $ENV{'TMPDIR'};
 $tmpdir = "/tmp" unless ( $tmpdir);
 if ( ! -d $tmpdir ) { 
  die "Temporary dir $tmpdir does not exist\n";
 }

 #
 # Create and check local tree variables
 #
 $localmod = $ARGV[0];
 $localdir = "${asimdir}/${localmod}";

 usage() unless ( $localmod );
 die "directory $localdir not found\n" unless ( -d $localdir);

 #
 # Create and check vendor tree variables
 #
 $vendormod = $ARGV[1];
 usage() unless ( $vendormod );

 #
 # Let's go into the local directory and make sure the user has an up-to-date,
 # checked in, clean copy of the code.
 #
 $clean = 1;

 print "== Step 1 ==========================================================\n";
 print "Checking that your local tree is clean & up-to-date...\n";
 open(DIFF,"cvs diff $localdir 2>&1 |") || die "can't fork 'cvs diff': $!\n";
 while ( <DIFF> ) {
  if ( /Index:/ ) {
   print "File not up-to-date: $_";
   $clean = 0;
  }
  if ( /^cvs diff:/ ) {
   print $_;
  }
 }
 if ( $clean == 0 ) {
  $proceed = getinput("WARNING: YOUR TREE IS NOT CLEAN!!! Do you want me to proceed anyway?","n");
  conditional_exit($proceed);
 }

 #
 # Repeat operation comparing against -r HEAD
 #
 print "== Step 2 ==========================================================\n";
 print "Re-Checking that your local tree is clean & up-to-date...\n";
 print "(this time using -r HEAD, to make sure you didn't miss some check-in...\n";
 print "(yes, I know, slightly paranoid :-))\n";
 open(DIFF,"cvs diff -r $localdir 2>&1|") || die "can't fork 'cvs diff': $!\n";
 while ( <DIFF> ) {
  if ( /Index:/ ) {
   print "File not up-to-date: $_";
   $clean = 0;
  }
  if ( /^cvs diff:/ ) {
   print $_;
  }
 }

 if ( $clean == 0 ) {
  $proceed = getinput("WARNING: YOUR TREE IS NOT CLEAN!!! Do you want me to proceed anyway?","n");
  conditional_exit($proceed);
 }
 close DIFF;

 #
 # Checkout a clean, up-to-date copy of the VENDOR source code 
 #
 print "== Step 3 ==========================================================\n";
 print "I need to check out a clean copy of the tree to be imported\n";
 print "If you already have a directory that contains that clean code, you\n";
 print "can now enter it. If you simply press <cr>, I will check it out myself\n";
 print "under a directory in $tmpdir\n\n";
 $oldcodir = "${tmpdir}/$ENV{'USER'}_$$";
 $codir = getinput("Vendor source directory?",$oldcodir); 

 if ( $codir eq $oldcodir ) {
  #
  # Create a temportary directory
  #
  print "Creating $codir\n";
  mkdir $codir, 0755;

  #
  # Because 'vendormod' does not include the prefix 'asim', we need to put it here
  # so that cvs finds the code we want
  #
  $comod = "asim/$vendormod";
  system("cd $codir; cvs checkout $comod");
 }


 #
 # Let's go back to the LOCAL source tree.
 # find a file (any file is good) that we can use to run 'cvs log' and get the information
 # we need about symbolic names and stuff...
 #
 print "== Step 4 ==========================================================\n";
 print "Extracting symbolic tag information...\n";

 #
 # Find some .h file
 #
 open(AFILE,"cd $localdir ; find . -name '*.h' -print |") || die "can't fork 'find' command: $!\n";
 while ( <AFILE> ) {
  next if ( ! /\.h$/ );
  chop $_;
  $afile = $_;
  last;
 }
 close (AFILE);

 #
 # Check we have got something that exists
 #
 if ( ! -s "$localdir/$afile" ) {
  die "Could not find file $localdir/$afile\n";
 }

 #
 # Now run 'cvs log' and search for the intereting SYMBOLIC names that we need
 #
 open(LOG,"cd $localdir ; cvs log $afile |") || die "can't fork 'cvs log': $!\n";

 #
 # Skip until we get to the symbolic names part
 #
 while ( <LOG> ) {
  last if ( /^symbolic names:/ );
 }

 while ( <LOG> ) {
  last if ( /^keyword substitution:/ );

  #
  # Clean blank spaces
  #
  s/\s+//g;

  #
  # Break lines of form "AUTO_TAG_23:1.1.1.1" into two pieces
  #
  ( $tag, $ver ) = split /:/;	
  print STDERR ">$tag< --> >$ver<\n";

  #
  # Build two hashes, one that goes from NAME to VERSION
  # and one that goes from VERSION to NAME. Note that the second
  # one might have multiple names mapping to the same version (and,
  # therefore, we need a hash-of-arrays)
  #
  $tag2ver{$tag} = $ver;
  push( @{ $ver2tag{$ver} },$tag);
 }
 close (LOG);


 #
 # At this point, we deal with the symbolic tags in the file. We must find the following
 # stuff:
 #  (a) What is the name corresponding to distribution 1.1.1 (this will give us the base name
 #      to be used as the version identifier)
 #
 #  (c) What is the higer tag name found (i.e. ARANA_DIST_1, ARANA_DIST_2, ARANA_DIST_3, etc...)
 #
 print "== Step 5 ==========================================================\n";

 #
 # (a) Vendor symbolic name
 #
 $distname = @{$ver2tag{"1.1.1"}}[0];
 $distname = getinput("VENDOR tag name",$distname);

 #
 # (b) find the special name 'LATEST_IMPORT_MERGED'
 #
 die "Unable to find version 'LATEST_IMPORT_MERGED'\n" unless ( $tag2ver{"LATEST_IMPORT_MERGED"} );

 #
 # (c) Highest tag name derived from the vendor symbolic name
 #
 #     If the vendor name is "ARANA_DIST", then each time we import its
 #     source code we use a derived symbolic tag of the form:
 #
 #      ARANA_DIST_{number}
 #
 #     where number increases monotonically starting at 1.
 #     We want to find the highest of such symbolic tags. So that we can use the 
 #     following one to do an import of the source tree.
 #
 $i = 1;
 for ( $i = 1; ; $i++ ) {
  $htag = $distname . "_" . $i;
  if ( $tag2ver{$htag} ) {
   $lasthtag = $htag;
  }
  else {
   last;
  }
 }
 $htag = $lasthtag;
 $next_tag_index = $i;
 print "Highest distribution tag: $htag\n";

 #
 # Now do an import of the vendor code into our source tree using the distribution name we discovered
 # and the next_tag_index
 #  
 print "== Step 6 ==========================================================\n";
 $date = rcs_date();
 $msg = "Automatic import, ${distname}_$next_tag_index, $date";
 $ntag = $distname . "_" . $next_tag_index;
 $import = "cvs import -m \"$msg\" asim/$localmod $distname $ntag";
 $dir = "${codir}/asim/${vendormod}";

 #
 # Inform the user about the import and let him decide whether to proceed or not...
 # 
 print "I'am going to:\n";
 print " (1) Change dir to $dir\n";
 print " (2) Execute: $import\n\n";
 $proceed = getinput("Do you want me to proceed?","y");
 conditional_exit($proceed);

 #
 # Do the import
 #
 system("cd $dir; $import");



 #
 # The 'cvs import' command only changes the repository... We must use checkout to actually do the
 # merge with our local code
 #  
 print "== Step 7 ==========================================================\n";
 $dir = "$asimdir/..";
 $checkout = "cvs checkout -jLATEST_IMPORT_MERGED -j${ntag} asim/$localmod";

 print "I'am going to:\n";
 print " (1) Change dir to $dir\n";
 print " (2) Execute: $checkout\n\n";
 $proceed = getinput("Do you want me to proceed?","y");
 conditional_exit($proceed);

 #
 # Do the checkout
 #
 system("cd $dir; $checkout");

 print "== Step 7a ==========================================================\n";
 print "At this point you can go check that you are (mostly) satisfied with\n";
 print "the merge. If this is not the case, this is your opportunity to abort.\n";
 print "From here onwards, I will be removing tags (Step 8) and then setting\n";
 print "the new LATEST_IMPORT_MERGED tag to the just-imported source tree\n";
 print "(Step 9)\n\n";

 $proceed = getinput("Do you want me to proceed?","y");
 conditional_exit($proceed);

 #
 # Destory the LATEST_IMPORT_MERGED tag
 #
 print "== Step 8 ==========================================================\n";
 print "Destroying tag 'LATEST_IMPORT_MERGED'...\n";
 system "cvs rtag -d LATEST_IMPORT_MERGED asim/$localmod";

 #
 # Tag the current import as the LATEST one successfully merged...
 #
 print "== Step 9 ==========================================================\n";
 print "Tagging this import with 'LATEST_IMPORT_MERGED'...\n";
 system "cvs rtag -r${ntag} LATEST_IMPORT_MERGED asim/$localmod";

 #
 # Clean up
 #
 print "== Step 10 ==========================================================\n";
 print "Cleaning up...\n";
 system "rm -rf $codir\n";
